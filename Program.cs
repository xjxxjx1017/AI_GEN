using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AI_GEN
{
	class Program
	{
		static public List<Universe> lastTest;
		static public List<string> lastCommand;
		static void Main( string[] args )
		{
			// * Show some 'help' at the start of the program
			printHelp( );
			// * Prevent the console from shutting down.
			string command = "";
			lastCommand = new List<string>( );
			while ( command.Equals( "quit" ) == false )
			{
				command = Console.ReadLine( );
				// [] Stop any false command from breaking the program
				try
				{
					// * Do some command
					doCommand( command );
				}
				catch( Exception e )
				{
				}
			}
		}

		static public void doCommand( string command )
		{
			// # parse command as a lower case string
			command = command.ToLower( );
			// * Split the command in to little commands
			List<string> commands = SystemPlus.splitCommand( command );
			// * Save the command as the last command
			if ( commands[0] != "r" && ( lastCommand.Count == 0 || lastCommand[lastCommand.Count - 1] != command ) )
				lastCommand.Add( command );
			// * Parse commands and run it !
			parseCommand( commands );
		}

		static public void parseCommand( List<string> commands )
		{
			int[] parameters = new int[10];
			switch ( commands[0] )
			{
				case "help":
					// * Show some 'help'
					printHelp( );
					break;
				case "start":
					// * Run a standard test
					runTest( );
					break;
				case "filter":
					// * Run a filter test, only record the test we wanted
					parameters[0] = Convert.ToInt32( commands[1] );
					parameters[1] = Convert.ToInt32( commands[2] );
					parameters[2] = Convert.ToInt32( commands[3] );
					parameters[3] = Convert.ToInt32( commands[4] );
					runFilterTest( 10, parameters[0], parameters[1], parameters[2], parameters[3] );
					break;
				case "single":
					// * Run a serials test for a single configuration generated by a certain seed
					parameters[0] = Convert.ToInt32( commands[1] );
					parameters[1] = Convert.ToInt32( commands[2] );
					runSingleTest( parameters[0], parameters[1] );
					break;
				case "r":
					// * Redo the last 'n' command
					if ( commands.Count > 1 )
					{
						parameters[0] = Convert.ToInt32( commands[1] );
						string commandL = lastCommand[ lastCommand.Count - parameters[0] ];
						doCommand( commandL );
					}
					else
						doCommand( lastCommand[ lastCommand.Count - 1 ] );
					break;
				default:
					// * If the input is an integer, print the config id
					int id = Convert.ToInt32( commands[0] );
					if ( id > 0 )
					{
						string config;
						int index = id - 1;
						int seed = lastTest[index].seed;
						config = DynamicConfig.generate( seed ).ToString( );
						Console.WriteLine( config );
						Console.WriteLine( lastTest[index].ToStringLimit( 20 ) );
					}
					break;
			}
		}

		static public void printHelp()
		{
			Console.WriteLine( "////////////// HELP //////////////////" );
			Console.WriteLine( "help"
							+ "\n\t\tFor help" );
			Console.WriteLine( "start"
							+ "\n\t\tRun a standard test" );
			Console.WriteLine( "filter x x x x"
							+ "\n\t\tRun a filter test, only record the test we wanted" );
			Console.WriteLine( "\t\t\tp1: min years\n"
							+ "\t\t\tp2: max years\n"
							+ "\t\t\tp3: min ships\n"
							+ "\t\t\tp4: max ships" );
			Console.WriteLine( "single x x"
							+ "\n\t\tRun a serials test for a single configuration generated \n\t\t"
							+ "by a certain seed" );
			Console.WriteLine( "\t\t\tp1: a fixed seed for the simulation\n"
							+ "\t\t\tp2: number of times for the simulation\n" );
			Console.WriteLine( "r (x)"
							+ "\n\t\tRedo the last 'n' command" );
			Console.WriteLine( "\t\t\tp1 (=1): define the number of 'n'\n" );
			Console.WriteLine( "[integer]"
							+ "\n\t\tIf the input is an integer, print the detail of a test has \n\t\t"
							+ "the same ID as the integer" );
			Console.WriteLine( "//////////////////////////////////////" );
					
		}

		static public void printResult( List<Universe> uList  )
		{
			Console.Clear( );
			for ( int i = 0; i < uList.Count; i++ )
			{
				Universe u = uList[i];
				Console.WriteLine( "ID: " + (i+1) +
					"\tSeed: " + u.seed +
					"\tEnd year: " + u.rlt_endYear +
					"\tShip count: " + u.rlt_shipCount );
			}
		}

		static public void runSingleTest( int seed, int times )
		{
			// * Config params for testing
			List<Universe> uList = new List<Universe>( );
			int universeMax = times;
			// * Run test for a fixed seed
			while ( uList.Count < universeMax )
			{
				Universe u = new Universe( );
				u.run( seed );
				uList.Add( u );
			}
			// [] Print results
			printResult( uList );
			lastTest = uList;
		}

		static public void runFilterTest( int count, int minYear, int maxYear, int minShips, int maxShips )
		{
			// * Config params for testing
			List<Universe> uList = new List<Universe>( );
			int universeMax = 10;
			// * Run test
			int seed = 1;
			while( uList.Count < universeMax )
			{
				Universe u = new Universe( );
				u.run( seed );
				if ( u.rlt_endYear <= maxYear
					&& u.rlt_endYear >= minYear
					&& u.rlt_shipCount >= minShips
					&& u.rlt_shipCount <= maxShips )
					uList.Add( u );
				seed++;
			}
			// [] Print results
			printResult( uList );
			lastTest = uList;
		}

		static public void runTest( int count = 30 )
		{
			// * Config params for testing
			List<Universe> uList = new List<Universe>( );
			int universeMax = 30;
			// * Run test
			for ( int i = 1; i <= universeMax; i++ )
			{
				Universe u = new Universe( );
				uList.Add( u );
				u.run( i );
			}
			// [] Print results
			printResult( uList );
			lastTest = uList;
		}
	}
}
